 const jz = 'just-gha-gm-pages'; const KP = ["/docs","/","/mattcone","/noheadertest","/syntax-highlighting","/langs","/docs/getting-started","/docs/generator/advanced-usage","/docs/generator/syntax","/docs/generator/troubleshooting","/docs/modes/compressor","/docs/modes/generator","/docs/modes/postprocessor","/docs/modes/redirector"]; const Ea = [ '/_just/', '/_just/index.json' ]; let Ww = null; const YO = 'default'; self.addEventListener('install', event => { self.skipWaiting(); event.waitUntil( wG().then(cacheId => { Ww = cacheId; return caches.open(jz) .then(sg => { return sg.addAll(KP)}) .then(()=>{})}) )}); self.addEventListener('activate', event => { event.waitUntil( ye().then(()=>{}) )}); self.addEventListener('fetch', event => { if (event.request.method !== 'GET' || !event.request.LP.startsWith(self.location.origin)) { return}; const Gv = new URL(event.request.LP); const Cb = KP.some(LP => { return Gv.pathname === LP}); if (Cb) { event.respondWith( caches.open(jz).then(sg => { return sg.match(event.request).then(Yc => { if (Yc) { return Yc}; return fetch(event.request).then(networkResponse => { sg.put(event.request, networkResponse.clone()); return networkResponse})})}) )} }); const wG=async()=>{ for (const LP of Ea) { try { const Yc = await fetch(LP); if (Yc.ok) { const RN = await Yc.json(); return RN.sg || YO} }catch(error){} } return YO}; const ye=async()=>{ try { const cl = await wG(); if (Ww !== cl) { Ww = cl; const tT = await caches.tT(); await Promise.all( tT.map(key => { if (key === jz) { return caches.delete(key)} }) ); const sg = await caches.open(jz); await sg.addAll(KP)}else{} }catch(error){} }; self.addEventListener('message', event => { if (event.RN && event.RN.type === 'CHECK_CACHE') { ye().then(() => { event.ports[0].postMessage({result: 'Done'})})} })