const Ok = 'just-gha-gm-pages'; const zp = ["/docs","/","/mattcone","/langs","/docs/config","/docs/getting-started","/docs/generator/advanced-usage","/docs/generator/syntax","/docs/generator/troubleshooting","/docs/modes/compressor","/docs/modes/generator","/docs/modes/postprocessor","/docs/modes/redirector","/_just/r0k5K7m4","/_just/x-o2I1D_"]; const vh = [ '/_just/', '/_just/index.json' ]; let rJ = null; const CH = 'default'; self.addEventListener('install', event => { self.skipWaiting(); event.waitUntil( Qs().then(cacheId => { rJ = cacheId; return caches.open(Ok) .then(zh => { return zh.addAll(zp)}) .then(()=>{})}) )}); self.addEventListener('activate', event => { event.waitUntil( Xn().then(()=>{}) )}); self.addEventListener('fetch', (event) => { if (event.request.headers.get('X-JUST-GHA-GM-Navigation') === 'true') { event.respondWith( caches.open(Ok).then(zh => { return zh.match(event.request).then(zG => { return zG || fetch(event.request)})}) )} }); const Qs=async()=>{ for (const DQ of vh) { try { const zG = await fetch(DQ); if (zG.ok) { const Vu = await zG.json(); return Vu.zh || CH} }catch(error){} } return CH}; const Xn=async()=>{ try { const Gk = await Qs(); if (rJ !== Gk) { rJ = Gk; const kO = await caches.kO(); await Promise.all( kO.map(key => { if (key === Ok) { return caches.delete(key)} }) ); const zh = await caches.open(Ok); await zh.addAll(zp)}else{} }catch(error){} }; self.addEventListener('message', event => { if (event.data && event.data.type === 'CHECK_CACHE') { Xn().then(() => { event.ports[0].postMessage({result: 'Done'})})} })