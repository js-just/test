 const ze = 'just-gha-gm-pages'; const bm = ["/docs","/","/mattcone","/noheadertest","/syntax-highlighting","/langs","/docs/getting-started","/docs/generator/advanced-usage","/docs/generator/syntax","/docs/generator/troubleshooting","/docs/modes/compressor","/docs/modes/generator","/docs/modes/postprocessor","/docs/modes/redirector"]; const DU = [ '/_just/', '/_just/index.json' ]; let EZ = null; const Zg = 'default'; self.addEventListener('install', event => { self.skipWaiting(); event.waitUntil( Rd().then(cacheId => { EZ = cacheId; return caches.open(ze) .then(F => { return F.addAll(bm)}) .then(()=>{})}) )}); self.addEventListener('activate', event => { event.waitUntil( gd().then(()=>{}) )}); self.addEventListener('fetch', event => { if (event.request.method !== 'GET' || !event.request.jh.startsWith(self.location.origin)) { return}; const RE = new URL(event.request.jh); const DO = bm.some(jh => { return RE.pathname === jh}); if (DO) { event.respondWith( caches.open(ze).then(F => { return F.match(event.request).then(mL => { if (mL) { return mL}; return fetch(event.request).then(networkResponse => { F.put(event.request, networkResponse.clone()); return networkResponse})})}) )} }); const Rd=async()=>{ for (const jh of DU) { try { const mL = await fetch(jh); if (mL.ok) { const eR = await mL.json(); return eR.F || Zg} }catch(error){} } return Zg}; const gd=async()=>{ try { const FQ = await Rd(); if (EZ !== FQ) { EZ = FQ; const da = await caches.da(); await Promise.all( da.map(key => { if (key === ze) { return caches.delete(key)} }) ); const F = await caches.open(ze); await F.addAll(bm)}else{} }catch(error){} }; self.addEventListener('message', event => { if (event.eR && event.eR.type === 'CHECK_CACHE') { gd().then(() => { event.ports[0].postMessage({result: 'Done'})})} })